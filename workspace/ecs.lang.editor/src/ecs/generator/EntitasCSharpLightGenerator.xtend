/*
 * generated by Xtext 2.10.0
 */
package ecs.generator

import ecs.lang.AComponent
import ecs.lang.Alias
import ecs.lang.Component
import ecs.lang.ParentSystem
import ecs.lang.Project
import ecs.lang.System
import ecs.model.ComponentModel
import java.util.ArrayList
import java.util.HashMap
import java.util.List
import java.util.Set
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class EntitasCSharpLightGenerator implements ILangGenerator {

	override void generate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val namespace = resource.namespace
		val allComponents = resource.collectAllComponents()
		for (component : allComponents) {
			fsa.generateFile("components/" + component.name.toFirstUpper + "Component.cs", component.generate(namespace))
		}
		val project = resource.contents.filter(typeof(Project)).get(0) as Project
		
		if (project.contextDefinitions.isEmpty){
			fsa.generateFile("componentIds/ComponentIds.cs", generateComponentsFile(allComponents, namespace))
		} else {
			val contextNameToComponentModel = computeContextNameToComponentModel(allComponents)
			for (contextName : contextNameToComponentModel.keySet){
				fsa.generateFile('''componentIds/«contextName»ComponentIds.cs''', generateComponentIdsFile(contextName, contextNameToComponentModel.get(contextName).sortBy[it.name], namespace))
				//fsa.generateFile('''attributes/«contextName»Attribute.cs''', generateAttributeFile(contextName, namespace))
			}
			fsa.generateFile('''pools/Pools.cs''', generatePoolsFile(contextNameToComponentModel.keySet.sortBy[it], namespace))
		}
		
	}
	
	private def HashMap<String, Set<ComponentModel>> computeContextNameToComponentModel(List<ComponentModel> allComponents) {
		val contextNameToComponentModel = <String, Set<ComponentModel>>newHashMap()
		for (component : allComponents){
			if (component.contexNames != null){
				for (ctxName : component.contexNames){
					var set = contextNameToComponentModel.get(ctxName)
					if (set == null){
						set = newHashSet()
					}
					set.add(component)
					contextNameToComponentModel.put(ctxName, set)
				}
			}
			
		}
		return contextNameToComponentModel
	}
	
	def String generate(ComponentModel model, String namespace) '''
		«IF namespace != null»
		namespace «namespace» {
		«ENDIF»
		using Entitas;
		public class «model.name.toFirstUpper»Component : IComponent {
			«FOR propertyName : model.properties.keySet»
			public «model.properties.get(propertyName)» «propertyName»;
			«ENDFOR»
		}
		«IF namespace != null»
		}
		«ENDIF»
		
		namespace Entitas {
			«IF namespace != null»
			using «namespace»;
			«ENDIF»
			public partial class Entity {
				«IF model.properties.empty»
				static readonly «model.name.toFirstUpper»Component «model.name.toFirstLower»Component = new «model.name.toFirstUpper»Component();

				public bool «model.prefix»«model.name.toFirstUpper» {
					get { return HasComponent(«model.componentIdByName»); }
					set {
						if (value != «model.prefix»«model.name.toFirstUpper») {
							if (value) {
								AddComponent(«model.componentIdByName», «model.name.toFirstLower»Component);
							} else {
								RemoveComponent(«model.componentIdByName»);
							}
						}
					}
				}
				
				public Entity «model.prefix.toFirstUpper»«model.name.toFirstUpper»(bool value) {
					«model.prefix»«model.name.toFirstUpper» = value;
					return this;
				}
				«ELSE»
				public «model.name.toFirstUpper»Component «model.name.toFirstLower» { get { return («model.name.toFirstUpper»Component)GetComponent(«model.componentIdByName»); } }
				public bool has«model.name.toFirstUpper» { get { return HasComponent(«model.componentIdByName»); } }
				public Entity Add«model.name.toFirstUpper»(«FOR propertyName : model.properties.keySet SEPARATOR ', '»«model.properties.get(propertyName)» new«propertyName.toFirstUpper»«ENDFOR») {
					var component = CreateComponent<«model.name.toFirstUpper»Component>(«model.componentIdByName»);
					«FOR propertyName : model.properties.keySet»
					component.«propertyName» = new«propertyName.toFirstUpper»;
					«ENDFOR»
					return AddComponent(«model.componentIdByName», component);
				}
				public void Add«model.name.toFirstUpper»_(«FOR propertyName : model.properties.keySet SEPARATOR ', '»«model.properties.get(propertyName)» new«propertyName.toFirstUpper»«ENDFOR») {
					var component = CreateComponent<«model.name.toFirstUpper»Component>(«model.componentIdByName»);
					«FOR propertyName : model.properties.keySet»
					component.«propertyName» = new«propertyName.toFirstUpper»;
					«ENDFOR»
					AddComponent(«model.componentIdByName», component);
				}
				public Entity Replace«model.name.toFirstUpper»(«FOR propertyName : model.properties.keySet SEPARATOR ', '»«model.properties.get(propertyName)» new«propertyName.toFirstUpper»«ENDFOR») {
					var component = CreateComponent<«model.name.toFirstUpper»Component>(«model.componentIdByName»);
					«FOR propertyName : model.properties.keySet»
					component.«propertyName» = new«propertyName.toFirstUpper»;
					«ENDFOR»
					ReplaceComponent(«model.componentIdByName», component);
					return this;
				}
				public Entity Remove«model.name.toFirstUpper»() {
					return RemoveComponent(«model.componentIdByName»);
				}
				«ENDIF»
			}
			«IF model.unique»
			public partial class Pool {
				«IF model.properties.empty»
				public Entity «model.name.toFirstLower»Entity { get { return GetGroup(«model.matcherByName»).GetSingleEntity(); } }
				public bool «model.prefix»«model.name.toFirstUpper» {
					get { return «model.name.toFirstLower»Entity != null; }
					set {
						var entity = «model.name.toFirstLower»Entity;
						if (value != (entity != null)) {
							if (value) {
								CreateEntity().«model.prefix»«model.name.toFirstUpper» = true;
							} else {
								DestroyEntity(entity);
							}
						}
					}
				}
				«ELSE»
				public Entity «model.name.toFirstLower»Entity { get { return GetGroup(«model.matcherByName»).GetSingleEntity(); } }
				
				public «model.name.toFirstUpper»Component «model.name.toFirstLower» { get { return «model.name.toFirstLower»Entity.«model.name.toFirstLower»; } }
				
				public bool has«model.name.toFirstUpper» { get { return «model.name.toFirstLower»Entity != null; } }
				
				public Entity Set«model.name.toFirstUpper»(«FOR propertyName : model.properties.keySet SEPARATOR ', '»«model.properties.get(propertyName)» new«propertyName.toFirstUpper»«ENDFOR») {
					if (has«model.name.toFirstUpper») {
						throw new EntitasException("Could not set «model.name.toFirstLower»!\n" + this + " already has an entity with «model.name.toFirstUpper»Component!",
							"You should check if the pool already has a «model.name.toFirstLower»Entity before setting it or use pool.Replace«model.name.toFirstUpper»().");
					}
					var entity = CreateEntity();
					entity.Add«model.name.toFirstUpper»(«FOR propertyName : model.properties.keySet SEPARATOR ', '»new«propertyName.toFirstUpper»«ENDFOR»);
					return entity;
				}
				
				public Entity Replace«model.name.toFirstUpper»(«FOR propertyName : model.properties.keySet SEPARATOR ', '»«model.properties.get(propertyName)» new«propertyName.toFirstUpper»«ENDFOR») {
					var entity = «model.name.toFirstLower»Entity;
					if (entity == null) {
						entity = Set«model.name.toFirstUpper»(«FOR propertyName : model.properties.keySet SEPARATOR ', '»new«propertyName.toFirstUpper»«ENDFOR»);
					} else {
						entity.Replace«model.name.toFirstUpper»(«FOR propertyName : model.properties.keySet SEPARATOR ', '»new«propertyName.toFirstUpper»«ENDFOR»);
					}
				
					return entity;
				}
				
				public void Remove«model.name.toFirstUpper»() {
					DestroyEntity(«model.name.toFirstLower»Entity);
				}
				«ENDIF»
			}
			«ENDIF»
			«IF model.contexNames == null || model.contexNames.size == 0»
			public partial class Matcher {
				static IMatcher _matcher«model.name.toFirstUpper»;
			
				public static IMatcher «model.name.toFirstUpper» {
					get {
						if (_matcher«model.name.toFirstUpper» == null) {
							var matcher = (Matcher)Matcher.AllOf(«model.componentIdByName»);
							matcher.componentNames = ComponentIds.componentNames;
							_matcher«model.name.toFirstUpper» = matcher;
						}

						return _matcher«model.name.toFirstUpper»;
					}
				}
			}
			«ENDIF»
		}
		«IF model.contexNames != null && model.contexNames.size > 0»
		«FOR contexName : model.contexNames»
		public partial class «contexName»Matcher {
			static IMatcher _matcher«model.name.toFirstUpper»;
		
			public static IMatcher «model.name.toFirstUpper» {
				get {
					if (_matcher«model.name.toFirstUpper» == null) {
						var matcher = (Matcher)Matcher.AllOf(«model.componentIdByName»);
						matcher.componentNames = «contexName»ComponentIds.componentNames;
						_matcher«model.name.toFirstUpper» = matcher;
					}

					return _matcher«model.name.toFirstUpper»;
				}
			}
		}
		«ENDFOR»
		«ENDIF»
	'''
	
	def String componentIdByName(ComponentModel model){
		if (model.contexNames == null || model.contexNames.size == 0){
			'''ComponentIds.«model.name.toFirstUpper»'''
		} else {
			'''«model.contexNames.get(0)»ComponentIds.«model.name.toFirstUpper»'''
		}
	}
	
	def String matcherByName(ComponentModel model){
		if (model.contexNames == null || model.contexNames.size == 0){
			'''Matcher.«model.name.toFirstUpper»'''
		} else {
			'''«model.contexNames.get(0)»Matcher.«model.name.toFirstUpper»'''
		}
	}
	
	def String getNamespace(Resource resource){
		val project = resource.contents.filter(typeof(Project)).get(0) as Project
		return project.namespace?.name
	}
	
	def List<ComponentModel> collectAllComponents(Resource resource) {
		val project = resource.contents.filter(typeof(Project)).get(0) as Project
		return project.collectAllComponents
	}
	
	public def List<ComponentModel> collectAllComponents(Project project) {
		val result = newLinkedList()
		project.components.forEach [
			val model = it.toComponentModel
			result.add(model)
		]
		project.typeAliases.filter[it.componentAlias].forEach [
			val model = it.toComponentModel
			result.add(model)
		]
		project.systems.filter[it.componentAlias].forEach [
			val model = it.toComponentModel
			result.add(model)
		]
		project.parentSystems.filter[it.componentAlias].forEach [
			val model = new ComponentModel()
			model.name = it.name
			model.unique = it.unique
			model.properties = newHashMap("value" -> "Entitas.Systems")
			result.add(model)
		]
		
		val lookupComponentNameToCtxName = <String, Set<String>>newHashMap()
		for(contextDef : project.contextDefinitions) {
			for(componentName : contextDef.components.map[name]) {
				var set = lookupComponentNameToCtxName.get(componentName)
				if (set == null){
					set = <String>newHashSet() 
				}
				for(contextName : contextDef.name){
					set.add(contextName)
				}
				lookupComponentNameToCtxName.put(componentName, set)
			}
		}
		
		result.addIndexAndContextNames(project)
		
		return result
	}
	
	private static class NameCountWeight implements Comparable<NameCountWeight>{
		String name
		int count
		double weight
	
	new(String string, int i, double d) {
		name = string
		count = i
		weight = d
	}
		
		override compareTo(NameCountWeight o) {
			if (o == null){
				return -1
			}
			var result = this.weight.compareTo(o.weight) * -1
			if (result == 0){
				result = this.count.compareTo(o.count) * -1			
			}
			if (result == 0){
				result = this.name.compareTo(o.name)
			}
			return result
		}
		
	}
	
	def addIndexAndContextNames(List<ComponentModel> components, Project project){
		val lookupComponentNameToCtxName = <String, Set<String>>newHashMap()
		val lookupCtxNameByComponentName = <String, Set<String>>newHashMap()
		val lookupComponentNameToWeight = <String, Double>newHashMap()
		val lookupComponentNameByIndex = <String, Integer>newHashMap()
		for(contextDef : project.contextDefinitions) {
			for(componentName : contextDef.components.map[name]) {
				var set1 = lookupComponentNameToCtxName.get(componentName)
				if (set1 == null){
					set1 = <String>newHashSet()
				}
				
				for(contextName : contextDef.name){
					var set2 = lookupCtxNameByComponentName.get(contextName)
					if (set2 == null){
						set2 = <String>newHashSet()
					}
					set1.add(contextName)
					set2.add(componentName)
					lookupCtxNameByComponentName.put(contextName, set2)
				}
				lookupComponentNameToCtxName.put(componentName, set1)
			}
		}
		for (contextName : lookupCtxNameByComponentName.keySet){
			val componentNames = lookupCtxNameByComponentName.get(contextName)
			val componentWeight = 1.0 / componentNames.size
			for(componentName : componentNames) {
				if (lookupComponentNameToWeight.get(componentName) == null){
					lookupComponentNameToWeight.put(componentName, componentWeight)
				} else {
					lookupComponentNameToWeight.put(componentName, Math.max(componentWeight, lookupComponentNameToWeight.get(componentName)))
				}
			}
		}
		val contextNamesBySize = lookupCtxNameByComponentName.keySet.sortBy[lookupCtxNameByComponentName.get(it).size].reverse
		for (contextName : contextNamesBySize){
			var index = 0
			var Set<Integer> assignedIndexies = newHashSet()
			val componentNamesSortedByOccurence = lookupCtxNameByComponentName.get(contextName).sortBy[new NameCountWeight(it, lookupComponentNameToCtxName.get(it).size, lookupComponentNameToWeight.get(it))]
			for (componentName : componentNamesSortedByOccurence){
				if (lookupComponentNameByIndex.get(componentName) != null){
					val addedToSet = assignedIndexies.add(lookupComponentNameByIndex.get(componentName))
					if (!addedToSet){
						throw new RuntimeException("Index collision detected")
					}
				}
			}
			for (componentName : componentNamesSortedByOccurence){
				if (lookupComponentNameByIndex.get(componentName) == null){
					while(assignedIndexies.contains(index)){
						index += 1
					}
					lookupComponentNameByIndex.put(componentName, index)
					assignedIndexies.add(index)
				}
			}
		}
		
		for(model : components) {
			model.contexNames = lookupComponentNameToCtxName.get(model.name)
			model.index = lookupComponentNameByIndex.get(model.name)
		}
		
		return lookupComponentNameByIndex
	}
	
	def ComponentModel toComponentModel(AComponent component){
		switch component {
			Component case component: return component.toComponentModel 
			System case component: return component.toComponentModel
			ParentSystem case component: return component.toComponentModel
			Alias case component : return component.toComponentModel
		}
		
		throw new Exception("Unexpected component type case " + component)
	}
	
	def ComponentModel toComponentModel(Component component){
		val model = new ComponentModel()
		model.name = component.name
		model.unique = component.unique
		val properties = newHashMap()
		if (component.valueType != null) {
			properties.put("value", component.valueType.typeName)
		} else {
			component.properties.forEach [
				val typeName = it.type.typeName
				properties.put(it.name, typeName)
			]
		}
		model.properties = properties
		if (properties.isEmpty){
			model.prefix = if(component.prefix == null) "is" else component.prefix
		}
		return model
	}
	
	def ComponentModel toComponentModel(Alias alias){
		val model = new ComponentModel()
		model.name = alias.name
		model.unique = alias.unique
		model.properties = newHashMap("value" -> alias.typeName)
		return model
	}
	
	def ComponentModel toComponentModel(System system){
		val model = new ComponentModel()
		model.name = system.name
		model.unique = system.unique
		model.properties = newHashMap("value" -> system.name.toUpperCase + "System")
		return model
	}
	
	def ComponentModel toComponentModel(ParentSystem system){
		val model = new ComponentModel()
		model.name = system.name
		model.unique = system.unique
		model.properties = newHashMap("value" -> system.name.toUpperCase + "Systems")
		return model
	}
	
	def String generateComponentsFile(List<ComponentModel> models, String namespace)'''
	«IF namespace != null»
	namespace «namespace» {
	«ENDIF»
	public static class ComponentIds {
		«FOR pair : models.sortBy[it.name].indexedList»
		public const int «pair.value.name.toFirstUpper» = «pair.key»;
		«ENDFOR»
		
		public const int TotalComponents = «models.size»;
	
		public static readonly string[] componentNames = {
			«FOR model : models.sortBy[it.name] SEPARATOR ","»
			"«model.name.toFirstUpper»"
			«ENDFOR»
		};
	
		public static readonly System.Type[] componentTypes = {
			«FOR model : models.sortBy[it.name] SEPARATOR ","»
			typeof(«model.name.toFirstUpper»Component)
			«ENDFOR»
		};
	}
	«IF namespace != null»
	}
	«ENDIF»
	'''
	
	def String generateComponentIdsFile(String contextName, List<ComponentModel> models, String namespace)'''
	«IF namespace != null»
	namespace «namespace» {
	«ENDIF»
	public static class «contextName»ComponentIds {
		«val count = models.sortBy[it.index].last.index + 1»
		«val map = models.groupBy[it.index]»
		«FOR model : models»
		public const int «model.name.toFirstUpper» = «model.index»;
		«ENDFOR»
		
		public const int TotalComponents = «count»;
	
		public static readonly string[] componentNames = {
			«FOR index : 0..< count SEPARATOR ","»
			«IF map.get(index).isNullOrEmpty»
			null
			«ELSE»
			"«map.get(index).get(0).name.toFirstUpper»"
			«ENDIF»
			«ENDFOR»
		};
	
		public static readonly System.Type[] componentTypes = {
			«FOR index : 0..< count SEPARATOR ","»
			«IF map.get(index).isNullOrEmpty»
			null
			«ELSE»
			typeof(«map.get(index).get(0).name.toFirstUpper»Component)
			«ENDIF»
			«ENDFOR»
		};
	}
	«IF namespace != null»
	}
	«ENDIF»
	'''
	
	def generateAttributeFile(String contextName, String namespace) '''
	using Entitas.CodeGenerator;
	«IF namespace != null»
	namespace «namespace» {
	«ENDIF»
	public class «contextName»Attribute : PoolAttribute {
	
		public «contextName»Attribute() : base("«contextName»") {
		}
	}
	«IF namespace != null»
	}
	«ENDIF»
	
	'''
	def generatePoolsFile(List<String> contextNames, String namespace) '''
	namespace Entitas {
	
		public partial class Pools {
			«FOR contextName : contextNames»
			public static Pool Create«contextName»Pool() {
				«val componentIds = if (namespace == null) {
					'''«contextName»ComponentIds'''
				} else {
					'''«namespace».«contextName»ComponentIds'''
				}»
				return CreatePool("«contextName»", «componentIds».TotalComponents, «componentIds».componentNames, «componentIds».componentTypes);
			}
			«ENDFOR»
		
			public Pool[] allPools { get { return new [] { «FOR contextName : contextNames SEPARATOR ", "»«contextName.toFirstLower»«ENDFOR» }; } }
			
			«FOR contextName : contextNames »
			public Pool «contextName.toFirstLower»;
			«ENDFOR»
			
			public void SetAllPools() {
				«FOR contextName : contextNames »
				«contextName.toFirstLower» = Create«contextName»Pool();
				«ENDFOR»
			}
		}
	}

	'''
	
	def <T> indexedList(List<T> models) {
		var result = new ArrayList<Pair<Integer, T>>();
		var index = 0
		for (T f : models){
			result.add(new Pair<Integer, T>(index, f))
			index += 1
		}
		result
	}
	
	def String getTypeName(Alias alias) {
		if (alias.singleAlias != null) {
			return alias.singleAlias.typeAlias
		}
		throw new Exception("Unexpected alias case " + alias)
	}
	
	def String getTypeName(AComponent component) {
		switch component {
			Component case component: return component.name.toFirstUpper + "Component" 
			System case component: return component.name.toFirstUpper + "Component"
			ParentSystem case component: return component.name.toFirstUpper + "Component"
			Alias case component : return component.name.toFirstUpper + "Component"
		}
		
		throw new Exception("Unexpected component type case " + component)
	}
	
	def boolean getIsFlag(AComponent component){
		switch component {
			Component case component: return component.valueType == null && component.properties.empty 
			System case component: return false
			ParentSystem case component: return false
			Alias case component : return false
		}
		
		throw new Exception("Unexpected component type case " + component)
	}
}
