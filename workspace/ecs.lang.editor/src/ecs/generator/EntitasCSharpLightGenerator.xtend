/*
 * generated by Xtext 2.10.0
 */
package ecs.generator

import ecs.lang.AComponent
import ecs.lang.Alias
import ecs.lang.Component
import ecs.lang.ContextDefinition
import ecs.lang.Chain
import ecs.lang.Project
import ecs.lang.System
import ecs.model.ComponentModel
import java.util.ArrayList
import java.util.HashMap
import java.util.List
import java.util.Set
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import ecs.lang.ContextName
import ecs.lang.CreateRule
import static extension ecs.model.ContextNameExtractor.*
import ecs.lang.Input
import ecs.lang.Group
import ecs.lang.UniqueComponentAccess

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class EntitasCSharpLightGenerator implements ILangGenerator {
	
	val components = <Component>newHashSet()
	val contextDefinitions = <ContextDefinition>newHashSet()
	val typeAliases = <Alias>newHashSet()
	val systems = <System>newHashSet()
	val chains = <Chain>newHashSet()
	val namespaces = <String>newHashSet()
	
	override void generate(Set<Project> projects, Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		setupModels(projects)
		if (namespaces.size > 1){
			throw new Exception("multiple namespaces are defined")
		}
		val namespace = namespaces.last
		val allComponents = collectAllComponents()
		for (component : allComponents) {
			fsa.generateFile("components/" + component.name.toFirstUpper + "Component.cs", component.generate(namespace))
		}
		
		val contextNameToComponentModel = computeContextNameToComponentModel(allComponents)
		for (contextName : contextNameToComponentModel.keySet){
			fsa.generateFile('''componentIds/«contextName»ComponentIds.cs''', generateComponentIdsFile(contextName, contextNameToComponentModel.get(contextName).sortBy[it.name], namespace))
			//fsa.generateFile('''attributes/«contextName»Attribute.cs''', generateAttributeFile(contextName, namespace))
		}
		for (system : systems){
			fsa.generateFile('''systems/«system.name.toFirstUpper»System.cs''', system.generateSystemFileContent.surroundWithNamespace(namespace))
		}
		
		fsa.generateFile('''pools/Pools.cs''', generatePoolsFile(contextNameToComponentModel.keySet.sortBy[it], namespace))
	}
	
	public def setupModels(Set<Project> projects){
		components.clear()
		projects.forEach[components.addAll(it.components)]
		contextDefinitions.clear()
		projects.forEach[contextDefinitions.add(it.contextDefinition)]
		typeAliases.clear()
		projects.forEach[typeAliases.addAll(it.typeAliases)]
		systems.clear()
		projects.forEach[systems.addAll(it.systems)]
		chains.clear()
		projects.forEach[chains.addAll(it.chains)]
		namespaces.clear()
		projects.forEach[if (it.namespace!=null) namespaces.add(it.namespace.name)]
	}
	
	private def HashMap<String, Set<ComponentModel>> computeContextNameToComponentModel(List<ComponentModel> allComponents) {
		val contextNameToComponentModel = <String, Set<ComponentModel>>newHashMap()
		for (component : allComponents){
			if (component.contexNames != null){
				for (ctxName : component.contexNames){
					var set = contextNameToComponentModel.get(ctxName)
					if (set == null){
						set = newHashSet()
					}
					set.add(component)
					contextNameToComponentModel.put(ctxName, set)
				}
			}
			
		}
		return contextNameToComponentModel
	}
	
	def String generate(ComponentModel model, String namespace) '''
		«IF namespace != null»
		namespace «namespace» {
		«ENDIF»
		using Entitas;
		public partial class «model.name.toFirstUpper»Component : IComponent {
			«FOR propertyName : model.properties.keySet»
			public «model.properties.get(propertyName)» «propertyName»;
			«ENDFOR»
		}
		«IF namespace != null»
		}
		«ENDIF»
		
		«val isInDefaultContext = model.contexNames == null || model.contexNames.size == 0 || model.contexNames.get(0).length == 0»
		namespace Entitas {
			«IF namespace != null»
			using «namespace»;
			«ENDIF»
			public partial class Entity {
				«IF model.properties.empty»
				static readonly «model.name.toFirstUpper»Component «model.name.toFirstLower»Component = new «model.name.toFirstUpper»Component();

				public bool «model.prefix»«model.name.toFirstUpper» {
					get { return HasComponent(«model.componentIdByName»); }
					set {
						if (value != «model.prefix»«model.name.toFirstUpper») {
							if (value) {
								AddComponent(«model.componentIdByName», «model.name.toFirstLower»Component);
							} else {
								RemoveComponent(«model.componentIdByName»);
							}
						}
					}
				}
				
				public Entity «model.prefix.toFirstUpper»«model.name.toFirstUpper»(bool value) {
					«model.prefix»«model.name.toFirstUpper» = value;
					return this;
				}
				«ELSE»
				public «model.name.toFirstUpper»Component «model.name.toFirstLower» { get { return («model.name.toFirstUpper»Component)GetComponent(«model.componentIdByName»); } }
				public bool has«model.name.toFirstUpper» { get { return HasComponent(«model.componentIdByName»); } }
				public Entity Add«model.name.toFirstUpper»(«FOR propertyName : model.properties.keySet SEPARATOR ', '»«model.properties.get(propertyName)» new«propertyName.toFirstUpper»«ENDFOR») {
					var component = CreateComponent<«model.name.toFirstUpper»Component>(«model.componentIdByName»);
					«FOR propertyName : model.properties.keySet»
					component.«propertyName» = new«propertyName.toFirstUpper»;
					«ENDFOR»
					return AddComponent(«model.componentIdByName», component);
				}
				public Entity Replace«model.name.toFirstUpper»(«FOR propertyName : model.properties.keySet SEPARATOR ', '»«model.properties.get(propertyName)» new«propertyName.toFirstUpper»«ENDFOR») {
					var component = CreateComponent<«model.name.toFirstUpper»Component>(«model.componentIdByName»);
					«FOR propertyName : model.properties.keySet»
					component.«propertyName» = new«propertyName.toFirstUpper»;
					«ENDFOR»
					ReplaceComponent(«model.componentIdByName», component);
					return this;
				}
				public Entity Remove«model.name.toFirstUpper»() {
					return RemoveComponent(«model.componentIdByName»);
				}
				«ENDIF»
			}
			«IF model.unique»
			public partial class Pool {
				«IF model.properties.empty»
				public Entity «model.name.toFirstLower»Entity { get { return GetGroup(«model.matcherByName»).GetSingleEntity(); } }
				public bool «model.prefix»«model.name.toFirstUpper» {
					get { return «model.name.toFirstLower»Entity != null; }
					set {
						var entity = «model.name.toFirstLower»Entity;
						if (value != (entity != null)) {
							if (value) {
								CreateEntity().«model.prefix»«model.name.toFirstUpper» = true;
							} else {
								DestroyEntity(entity);
							}
						}
					}
				}
				«ELSE»
				public Entity «model.name.toFirstLower»Entity { get { return GetGroup(«model.matcherByName»).GetSingleEntity(); } }
				
				public «model.name.toFirstUpper»Component «model.name.toFirstLower» { get { return «model.name.toFirstLower»Entity.«model.name.toFirstLower»; } }
				
				public bool has«model.name.toFirstUpper» { get { return «model.name.toFirstLower»Entity != null; } }
				
				public Entity Set«model.name.toFirstUpper»(«FOR propertyName : model.properties.keySet SEPARATOR ', '»«model.properties.get(propertyName)» new«propertyName.toFirstUpper»«ENDFOR») {
					if (has«model.name.toFirstUpper») {
						throw new EntitasException("Could not set «model.name.toFirstLower»!\n" + this + " already has an entity with «model.name.toFirstUpper»Component!",
							"You should check if the pool already has a «model.name.toFirstLower»Entity before setting it or use pool.Replace«model.name.toFirstUpper»().");
					}
					var entity = CreateEntity();
					entity.Add«model.name.toFirstUpper»(«FOR propertyName : model.properties.keySet SEPARATOR ', '»new«propertyName.toFirstUpper»«ENDFOR»);
					return entity;
				}
				
				public Entity Replace«model.name.toFirstUpper»(«FOR propertyName : model.properties.keySet SEPARATOR ', '»«model.properties.get(propertyName)» new«propertyName.toFirstUpper»«ENDFOR») {
					var entity = «model.name.toFirstLower»Entity;
					if (entity == null) {
						entity = Set«model.name.toFirstUpper»(«FOR propertyName : model.properties.keySet SEPARATOR ', '»new«propertyName.toFirstUpper»«ENDFOR»);
					} else {
						entity.Replace«model.name.toFirstUpper»(«FOR propertyName : model.properties.keySet SEPARATOR ', '»new«propertyName.toFirstUpper»«ENDFOR»);
					}
				
					return entity;
				}
				
				public void Remove«model.name.toFirstUpper»() {
					DestroyEntity(«model.name.toFirstLower»Entity);
				}
				«ENDIF»
			}
			«ENDIF»
			«IF isInDefaultContext»
			public partial class Matcher {
				static IMatcher _matcher«model.name.toFirstUpper»;
			
				public static IMatcher «model.name.toFirstUpper» {
					get {
						if (_matcher«model.name.toFirstUpper» == null) {
							var matcher = (Matcher)Matcher.AllOf(«model.componentIdByName»);
							matcher.componentNames = ComponentIds.componentNames;
							_matcher«model.name.toFirstUpper» = matcher;
						}

						return _matcher«model.name.toFirstUpper»;
					}
				}
			}
			«ENDIF»
		}
		«IF !isInDefaultContext»
		«FOR contexName : model.contexNames»
		public partial class «contexName»Matcher {
			static IMatcher _matcher«model.name.toFirstUpper»;
		
			public static IMatcher «model.name.toFirstUpper» {
				get {
					if (_matcher«model.name.toFirstUpper» == null) {
						var matcher = (Matcher)Matcher.AllOf(«model.componentIdByName»);
						matcher.componentNames = «contexName»ComponentIds.componentNames;
						_matcher«model.name.toFirstUpper» = matcher;
					}

					return _matcher«model.name.toFirstUpper»;
				}
			}
		}
		«ENDFOR»
		«ENDIF»
	'''
	
	def String componentIdByName(ComponentModel model){
		if (model.contexNames == null || model.contexNames.size == 0){
			'''ComponentIds.«model.name.toFirstUpper»'''
		} else {
			'''«model.contexNames.get(0)»ComponentIds.«model.name.toFirstUpper»'''
		}
	}
	
	def String matcherByName(ComponentModel model){
		if (model.contexNames == null || model.contexNames.size == 0){
			'''Matcher.«model.name.toFirstUpper»'''
		} else {
			'''«model.contexNames.get(0)»Matcher.«model.name.toFirstUpper»'''
		}
	}
	
	def String getNamespace(Resource resource){
		val project = resource.contents.filter(typeof(Project)).get(0) as Project
		return project.namespace?.name
	}
	
	public def List<ComponentModel> collectAllComponents() {
		val result = newLinkedList()
		components.forEach [
			val model = it.toComponentModel
			result.add(model)
		]
		typeAliases.filter[it.componentAlias].forEach [
			val model = it.toComponentModel
			result.add(model)
		]
		systems.filter[it.componentAlias].forEach [
			val model = it.toComponentModel
			result.add(model)
		]
		chains.filter[it.componentAlias].forEach [
			val model = it.toComponentModel
			result.add(model)
		]
		
		result.addIndexAndContextNames()
		
		return result
	}
	
	private static class NameCountWeight implements Comparable<NameCountWeight>{
		String name
		int count
		double weight
	
		new(String string, int i, double d) {
			name = string
			count = i
			weight = d
		}
		
		override compareTo(NameCountWeight o) {
			if (o == null){
				return -1
			}
			var result = this.weight.compareTo(o.weight) * -1
			if (result == 0){
				result = this.count.compareTo(o.count) * -1			
			}
			if (result == 0){
				result = this.name.compareTo(o.name)
			}
			return result
		}
		
	}
	
	def addIndexAndContextNames(List<ComponentModel> components){
		val lookupComponentNameToNumberOfCtx = <String, Integer>newHashMap()
		val lookupCtxNameByComponentName = <String, Set<String>>newHashMap()
		val lookupComponentNameToWeight = <String, Double>newHashMap()
		val lookupComponentNameByIndex = <String, Integer>newHashMap()
		
		for (component : components){
			lookupComponentNameToNumberOfCtx.put(component.name, component.contexNames.size)
			for (ctxName : component.contexNames){
				var set = lookupCtxNameByComponentName.get(ctxName)
				if (set == null){
					set = <String>newHashSet()
				}
				set.add(component.name)
				lookupCtxNameByComponentName.put(ctxName, set)
			}
		}
		for (contextName : lookupCtxNameByComponentName.keySet){
			val componentNames = lookupCtxNameByComponentName.get(contextName)
			val componentWeight = 1.0 / componentNames.size
			for(componentName : componentNames) {
				if (lookupComponentNameToWeight.get(componentName) == null){
					lookupComponentNameToWeight.put(componentName, componentWeight)
				} else {
					lookupComponentNameToWeight.put(componentName, Math.max(componentWeight, lookupComponentNameToWeight.get(componentName)))
				}
			}
		}
		val contextNamesBySize = lookupCtxNameByComponentName.keySet.sortBy[lookupCtxNameByComponentName.get(it).size].reverse
		for (contextName : contextNamesBySize){
			var index = 0
			var Set<Integer> assignedIndexies = newHashSet()
			val componentNamesSortedByOccurence = lookupCtxNameByComponentName.get(contextName).sortBy[new NameCountWeight(it, lookupComponentNameToNumberOfCtx.get(it), lookupComponentNameToWeight.get(it))]
			for (componentName : componentNamesSortedByOccurence){
				if (lookupComponentNameByIndex.get(componentName) != null){
					val addedToSet = assignedIndexies.add(lookupComponentNameByIndex.get(componentName))
					if (!addedToSet){
						throw new RuntimeException("Index collision detected")
					}
				}
			}
			for (componentName : componentNamesSortedByOccurence){
				if (lookupComponentNameByIndex.get(componentName) == null){
					while(assignedIndexies.contains(index)){
						index += 1
					}
					lookupComponentNameByIndex.put(componentName, index)
					assignedIndexies.add(index)
				}
			}
		}
		
		for(model : components) {
			//model.contexNames = lookupComponentNameToCtxName.get(model.name)
			model.index = lookupComponentNameByIndex.get(model.name)
		}
		
		return lookupComponentNameByIndex
	}
	
	def ComponentModel toComponentModel(AComponent component){
		switch component {
			Component case component: return component.toComponentModel 
			System case component: return component.toComponentModel
			Chain case component: return component.toComponentModel
			Alias case component : return component.toComponentModel
		}
		
		throw new Exception("Unexpected component type case " + component)
	}
	
	def ComponentModel toComponentModel(Component component){
		val model = new ComponentModel()
		model.name = component.name
		model.unique = component.unique
		val properties = newHashMap()
		if (component.valueType != null) {
			properties.put("value", component.valueType.typeName)
		} else {
			component.properties.forEach [
				val typeName = it.type.typeName
				properties.put(it.name, typeName)
			]
		}
		model.properties = properties
		if (properties.isEmpty){
			model.prefix = if(component.prefix == null) "is" else component.prefix
		}
		if(component.contextRef != null){		
			model.contexNames = newHashSet(component.contextRef.context.map[name])
		}
		
		return model
	}
	
	def ComponentModel toComponentModel(Alias alias){
		val model = new ComponentModel()
		model.name = alias.name
		model.unique = alias.unique
		model.properties = newHashMap("value" -> alias.typeName)
		if(alias.contextRef != null){		
			model.contexNames = newHashSet(alias.contextRef.context.map[name])
		}
		return model
	}
	
	def ComponentModel toComponentModel(System system){
		val model = new ComponentModel()
		model.name = system.name
		model.unique = system.unique
		model.properties = newHashMap("value" -> system.name.toFirstUpper + "SystemInterface")
		if(system.contextRef != null){		
			model.contexNames = newHashSet(system.contextRef.context.map[name])
		}
		return model
	}
	
	def ComponentModel toComponentModel(Chain system){
		val model = new ComponentModel()
		model.name = system.name
		model.unique = system.unique
		model.properties = newHashMap("value" -> system.name.toFirstUpper + "Systems")
		if(system.contextRef != null){		
			model.contexNames = newHashSet(system.contextRef.context.map[name])
		}
		return model
	}
	
	def String generateComponentsFile(List<ComponentModel> models, String namespace)'''
	«IF namespace != null»
	namespace «namespace» {
	«ENDIF»
	public static class ComponentIds {
		«FOR pair : models.sortBy[it.name].indexedList»
		public const int «pair.value.name.toFirstUpper» = «pair.key»;
		«ENDFOR»
		
		public const int TotalComponents = «models.size»;
	
		public static readonly string[] componentNames = {
			«FOR model : models.sortBy[it.name] SEPARATOR ","»
			"«model.name.toFirstUpper»"
			«ENDFOR»
		};
	
		public static readonly System.Type[] componentTypes = {
			«FOR model : models.sortBy[it.name] SEPARATOR ","»
			typeof(«model.name.toFirstUpper»Component)
			«ENDFOR»
		};
	}
	«IF namespace != null»
	}
	«ENDIF»
	'''
	
	def String generateComponentIdsFile(String contextName, List<ComponentModel> models, String namespace)'''
	«IF namespace != null»
	namespace «namespace» {
	«ENDIF»
	public static class «contextName»ComponentIds {
		«val count = models.sortBy[it.index].last.index + 1»
		«val map = models.groupBy[it.index]»
		«FOR model : models»
		public const int «model.name.toFirstUpper» = «model.index»;
		«ENDFOR»
		
		public const int TotalComponents = «count»;
	
		public static readonly string[] componentNames = {
			«FOR index : 0..< count SEPARATOR ","»
			«IF map.get(index).isNullOrEmpty»
			null
			«ELSE»
			"«map.get(index).get(0).name.toFirstUpper»"
			«ENDIF»
			«ENDFOR»
		};
	
		public static readonly System.Type[] componentTypes = {
			«FOR index : 0..< count SEPARATOR ","»
			«IF map.get(index).isNullOrEmpty»
			null
			«ELSE»
			typeof(«map.get(index).get(0).name.toFirstUpper»Component)
			«ENDIF»
			«ENDFOR»
		};
	}
	«IF namespace != null»
	}
	«ENDIF»
	'''
	
	def generateAttributeFile(String contextName, String namespace) '''
	using Entitas.CodeGenerator;
	«IF namespace != null»
	namespace «namespace» {
	«ENDIF»
	public class «contextName»Attribute : PoolAttribute {
	
		public «contextName»Attribute() : base("«contextName»") {
		}
	}
	«IF namespace != null»
	}
	«ENDIF»
	
	'''
	def generatePoolsFile(List<String> contextNames, String namespace) '''
	namespace Entitas {
	
		public partial class Pools {
			«FOR contextName : contextNames»
			public static Pool Create«contextName»Pool() {
				«val componentIds = if (namespace == null) {
					'''«contextName»ComponentIds'''
				} else {
					'''«namespace».«contextName»ComponentIds'''
				}»
				return CreatePool("«if(contextName!=""){contextName.toFirstLower}else{"pool"}»", «componentIds».TotalComponents, «componentIds».componentNames, «componentIds».componentTypes);
			}
			«ENDFOR»
		
			public Pool[] allPools { get { return new [] { «FOR contextName : contextNames SEPARATOR ", "»«if(contextName!=""){contextName.toFirstLower}else{"pool"}»«ENDFOR» }; } }
			
			«FOR contextName : contextNames »
			public Pool «if(contextName!=""){contextName.toFirstLower}else{"pool"}»;
			«ENDFOR»
			
			public void SetAllPools() {
				«FOR contextName : contextNames »
				«if(contextName!=""){contextName.toFirstLower}else{"pool"}» = Create«contextName»Pool();
				«ENDFOR»
			}
		}
	}
	'''
	
	def generateSystemFileContent(System system)'''
		using Entitas;
		«val interfaceNames = system.interfaceNames»
		public interface «system.name.toFirstUpper»SystemInterface : «FOR interfaceName : interfaceNames SEPARATOR ", "»«interfaceName»«ENDFOR»{}
		
		public abstract class «system.name.toFirstUpper»SystemBase : «system.name.toFirstUpper»SystemInterface {
			«FOR ctx : system.allContextNames»
			«val ctxName = ctx?.name.toFirstLower ?: "pool"»
			protected readonly Pool _«ctxName»;
			«ENDFOR»
			protected «system.name.toFirstUpper»SystemBase(«FOR ctx : system.allContextNames SEPARATOR ", "»«val ctxName = ctx?.name.toFirstLower ?: "pool"»Pool «ctxName»«ENDFOR»){
				«FOR ctx : system.allContextNames»
				«val ctxName = ctx?.name.toFirstLower ?: "pool"»
				_«ctxName» = «ctxName»;
				«ENDFOR»
			}
			
			
			«FOR uniqueComp : system.uniqueComp»
			«val ctxName = uniqueComp.contextName?.name.toFirstLower ?: "pool"»
			«val componentName = uniqueComp.apiRule.component.name.toFirstLower»
			«val fromPostfix = ""/*if(uniqueComp.contextName == null){""}else{"From"+ctxName.toFirstUpper}*/»
			«val inPostfix = ""/*if(uniqueComp.contextName == null){""}else{"In"+ctxName.toFirstUpper}*/»
			«val model = uniqueComp.apiRule.component.toComponentModel»
			«IF model.properties.isEmpty»
			protected bool «model.prefix»«componentName.toFirstUpper»«inPostfix» { 
				get { return _«ctxName».«model.prefix»«componentName.toFirstUpper»; }
				set { _«ctxName».«model.prefix»«componentName.toFirstUpper» = value; }
			}
			«ELSE»
			protected «uniqueComp.apiRule.component.typeName» «componentName»«fromPostfix» { get { return _«ctxName».«componentName»; } }
			protected bool has«componentName.toFirstUpper»«inPostfix» { get { return _«ctxName».has«componentName.toFirstUpper»; } }
			protected void Remove«componentName.toFirstUpper»«fromPostfix»() { 
				_«ctxName».Remove«componentName.toFirstUpper»();
			}
			protected Entity Set«componentName.toFirstUpper»«inPostfix»(«FOR propertyName : model.properties.keySet SEPARATOR ', '»«model.properties.get(propertyName)» new«propertyName.toFirstUpper»«ENDFOR») {
				return _«ctxName».Set«componentName.toFirstUpper»(«FOR propertyName : model.properties.keySet SEPARATOR ', '»new«propertyName.toFirstUpper»«ENDFOR»);
			}
			protected Entity Replace«componentName.toFirstUpper»«inPostfix»(«FOR propertyName : model.properties.keySet SEPARATOR ', '»«model.properties.get(propertyName)» new«propertyName.toFirstUpper»«ENDFOR») { 
				return _«ctxName».Replace«componentName.toFirstUpper»(«FOR propertyName : model.properties.keySet SEPARATOR ', '»new«propertyName.toFirstUpper»«ENDFOR»);
			}
			«ENDIF»
			«ENDFOR»
«««			Group
			«FOR group : system.groups»
			«val ctxName = group.contextName?.name.toFirstLower ?: "pool"»
			«val matcherPrefix = group.contextName?.name.toFirstUpper ?: ""»
			«IF group.isUnique»
			protected Entity «group.name.toFirstLower» { 
				get { 
					return _«ctxName».GetGroup(
									«IF !group.allOfComponents.empty»
									Matcher.AllOf(«FOR comp : group.allOfComponents SEPARATOR ", "»«matcherPrefix»Matcher.«comp.name.toFirstUpper»«ENDFOR»)«ENDIF»
									«IF !group.anyOfComponents.empty»
									«IF group.allOfComponents.empty»Matcher«ENDIF».AnyOf(«FOR comp : group.anyOfComponents SEPARATOR ", "»«matcherPrefix»Matcher.«comp.name.toFirstUpper»«ENDFOR»)«ENDIF»
									«IF !group.noneOfComponents.empty»
									«IF group.allOfComponents.empty && group.anyOfComponents.empty»Matcher«ENDIF».NoneOf(«FOR comp : group.noneOfComponents SEPARATOR ", "»«matcherPrefix»Matcher.«comp.name.toFirstUpper»«ENDFOR»)«ENDIF»
					).GetSingleEntity(); 
				} 
			}
			«ELSE»
			protected Group «group.name.toFirstLower» { 
				get { 
					return _«ctxName».GetGroup(
								«IF !group.allOfComponents.empty»
								Matcher.AllOf(«FOR comp : group.allOfComponents SEPARATOR ", "»«matcherPrefix»Matcher.«comp.name.toFirstUpper»«ENDFOR»)«ENDIF»
								«IF !group.anyOfComponents.empty»
								«IF group.allOfComponents.empty»Matcher«ENDIF».AnyOf(«FOR comp : group.anyOfComponents SEPARATOR ", "»«matcherPrefix»Matcher.«comp.name.toFirstUpper»«ENDFOR»)«ENDIF»
								«IF !group.noneOfComponents.empty»
								«IF group.allOfComponents.empty && group.anyOfComponents.empty»Matcher«ENDIF».NoneOf(«FOR comp : group.noneOfComponents SEPARATOR ", "»«matcherPrefix»Matcher.«comp.name.toFirstUpper»«ENDFOR»)«ENDIF»
					);
				}
			}
			«ENDIF»
			«IF group.isDestroy»
			protected void Destroy«group.name.toFirstUpper»(Entity e){
				_«ctxName».DestroyEntity(e);
			}
			«ENDIF»
			«ENDFOR»
«««			Create
			«FOR createRule : system.createRules»
			«val ctxName = createRule.contextName?.name.toFirstLower ?: "pool"»
			«val inPostfix = ""/*if(createRule.contextName == null){""}else{"In"+ctxName.toFirstUpper}*/»
			protected Entity Create«createRule.name.toFirstUpper»«inPostfix»(){
				return _«ctxName».CreateEntity();
			}
			«ENDFOR»
«««			SystemInterfaces
			«IF system.input == null»
			public abstract void Execute();
			«ELSE»
			public abstract void Execute(System.Collections.Generic.List<Entity> inputEntities);
			«ENDIF»
			
			«IF system.isInit»
			public abstract void Initialize();
			«ENDIF»
			«IF system.isCleanup»
			public abstract void Cleanup();
			«ENDIF»
			«IF system.isTeardown»
			public abstract void TearDown();
			«ENDIF»
			«IF system.input != null»
			«val inputCtxName = system.input.contextName?.name.toFirstUpper ?: ""»
			«val inputPoolName = system.input.contextName?.name.toFirstUpper ?: "pool"»
			public TriggerOnEvent[] triggers { get { return new [] {
					«FOR trigger : system.input.triggers SEPARATOR ", "»
					«IF !trigger.enterComponents.empty»
					Matcher.AllOf(«FOR comp : trigger.enterComponents SEPARATOR ", "»«inputCtxName»Matcher.«comp.name.toFirstUpper»«ENDFOR»).OnEntityAdded()
					«ENDIF»
					«IF !trigger.left.empty»
					Matcher.AllOf(«FOR comp : trigger.left SEPARATOR ", "»«inputCtxName»Matcher.«comp.name.toFirstUpper»«ENDFOR»).OnEntityRemoved()
					«ENDIF»
					«IF !trigger.enteredOrLeft.empty»
					Matcher.AllOf(«FOR comp : trigger.enteredOrLeft SEPARATOR ", "»«inputCtxName»Matcher.«comp.name.toFirstUpper»«ENDFOR»).OnEntityAddedOrRemoved()
					«ENDIF»
					«ENDFOR»
				};
			}}
			
			«IF !system.input.ensureComponents.empty»
			public IMatcher ensureComponents { get { return «inputCtxName»Matcher.AllOf(«FOR comp : system.input.ensureComponents SEPARATOR ", "»«inputCtxName»Matcher.«comp.name.toFirstUpper»«ENDFOR»); }}
			«ENDIF»
			«IF !system.input.excludeComponents.empty»
			public IMatcher excludeComponents { get { return «inputCtxName»Matcher.AllOf(«FOR comp : system.input.excludeComponents SEPARATOR ", "»«inputCtxName»Matcher.«comp.name.toFirstUpper»«ENDFOR»); }}
			«ENDIF»
			«IF system.input.isDestroy»
			protected void DestroyInput(Entity e){
				_«inputPoolName».DestroyEntity(e);
			}
			«ENDIF»
			«ENDIF»
		}
	'''
	
	def List<String>interfaceNames(System system){
		val interfaceNames = newArrayList()
		if(system.input == null){
			interfaceNames.add("IExecuteSystem")
		} else {
			interfaceNames.add("IMultiReactiveSystem")
			if(!system.input.excludeComponents.empty){
				interfaceNames.add("IExcludeComponents")
			}
			if(!system.input.ensureComponents.empty){
				interfaceNames.add("IEnsureComponents")
			}
		}
		if(system.isInit){
			interfaceNames.add("IInitializeSystem")
		}
		if(system.isCleanup){
			interfaceNames.add("ICleanupSystem")
		}
		if(system.isTeardown){
			interfaceNames.add("ITearDownSystem")
		}
		return interfaceNames
	}
	
	def Set<ContextName> allContextNames(System system){
		val result = <ContextName>newHashSet()
		if(system.contextRef != null){
			system.contextRef.context.forEach[result.add(it)]
		}
		system.createRules.forEach[result.add(it.contextName)]
		if(system.input != null){
			result.add(system.input.contextName)
		}
		system.groups.forEach[result.add(it.contextName)]
		system.uniqueComp.forEach[result.add(it.contextName)]
		return result 
	}
	
	def ContextName contextName(CreateRule rule){
		if (rule.contextRef != null){
			return rule.contextRef
		}
		rule.componentTypes.map[it].commonContextName.last
	}
	
	def ContextName contextName(UniqueComponentAccess rule){
		if (rule.contextRef != null){
			return rule.contextRef
		}
		newArrayList(rule.apiRule.component).commonContextName.last
	}
	
	def ContextName contextName(Group group){
		if (group.contextRef != null){
			return group.contextRef
		}
		val componentList = newLinkedList()
		group.apiRules.forEach[componentList.add(it.component)]
		group.anyOfComponents.forEach[componentList.add(it)]
		group.allOfComponents.forEach[componentList.add(it)]
		group.noneOfComponents.forEach[componentList.add(it)]
		
		return componentList.commonContextName.last 
	}
	
	def ContextName contextName(Input input){
		if (input.contextRef != null){
			return input.contextRef
		}
		val componentList = <AComponent>newArrayList()
		input.triggers.forEach[
			it.enterComponents.forEach[componentList.add(it)]
			it.left.forEach[componentList.add(it)]
			it.enteredOrLeft.forEach[componentList.add(it)]
		]
		input.apiRules.forEach[componentList.add(it.component)]
		
		input.ensureComponents.forEach[componentList.add(it)]
		input.excludeComponents.forEach[componentList.add(it)]
		
		return componentList.commonContextName.last
	}
	
	def surroundWithNamespace(CharSequence content, String namespace)'''
		«IF namespace != null»
		namespace «namespace» {
			«content»
		}
		«ELSE»
		«content»
		«ENDIF»
	'''
	
	def <T> indexedList(List<T> models) {
		var result = new ArrayList<Pair<Integer, T>>();
		var index = 0
		for (T f : models){
			result.add(new Pair<Integer, T>(index, f))
			index += 1
		}
		result
	}
	
	def String getTypeName(Alias alias) {
		if (alias.singleAlias != null) {
			return alias.singleAlias.typeAlias
		}
		throw new Exception("Unexpected alias case " + alias)
	}
	
	def String getTypeName(AComponent component) {
		switch component {
			Component case component: return component.name.toFirstUpper + "Component" 
			System case component: return component.name.toFirstUpper + "Component"
			Chain case component: return component.name.toFirstUpper + "Component"
			Alias case component : return component.name.toFirstUpper + "Component"
		}
		
		throw new Exception("Unexpected component type case " + component)
	}
	
	def boolean getIsFlag(AComponent component){
		switch component {
			Component case component: return component.valueType == null && component.properties.empty 
			System case component: return false
			Chain case component: return false
			Alias case component : return false
		}
		
		throw new Exception("Unexpected component type case " + component)
	}
}
